package cosc322;
import java.util.ArrayList;

public class GameTree {
	//TODO: instantiate Node based tree
	
	//use possibleQueenMoves(oldQueenRow,oldQueenCol) and possibleArrowMoves(newQueenRow,newQueenCol) to iteratively fill the node based tree
	GameBoard[][] board;
	Node root;
	
	
	public GameTree(GameBoard[][] board){
		this.board = board;
		this.root = new Node(board);
	}
	
	public void addChildren(Node n){ 
		//go through black moves then white moves and then iteratively call addChildren()
		for(int i=0;i<10;i++){
			for(int j=0;j<10;j++){
				if(board[i][j]!=null && board[i][j].toString().equals("Black Queen")){
					ArrayList<Queen> black_moves = possibleQueenMoves((Queen)board[i][j],board);
				}else if(board[i][j]!=null && board[i][j].toString().equals("White Queen")){
					ArrayList<Queen> white_moves = possibleQueenMoves((Queen)board[i][j],board);
				}
			}
		}
		
		
		//Create a clone of the board
		
		
	}
public ArrayList<Queen> possibleQueenMoves(Queen q,GameBoard[][] board){
		
		ArrayList<Queen> possibleMoves = new ArrayList<>();
		// 8 directional movement:
		int qrow = q.getQueenLocation()[0];
		int qcol = q.getQueenLocation()[1];
		String side = q.toString().substring(0,5);
		
		//Vertical-Up Check (Row Operation)
		for(int i=1;qrow-i>=0;i++){
			if(board[qrow-i][qcol]==null){
				possibleMoves.add(new Queen(qrow-i,qcol,side));
			}else{
				break;
			}
		}
		//Vertical-Down Check (Row Operation)
		for(int i=1;qrow+i<10;i++){
			if(board[qrow+i][qcol]==null){
				possibleMoves.add(new Queen(qrow+i,qcol,side));
			}else{
				break;
			}
		}
		//Horizontal-Left Check (Column Operation)
		for(int i=1;qcol-i>=0;i++){
			if(board[qrow][qcol-i]==null){
				possibleMoves.add(new Queen(qrow,qcol-i,side));
			}else{
				break;
			}
		}
		//Horizontal-Right Check (Column Operation)
		for(int i=1;qcol+i<10;i++){
			if(board[qrow][qcol+i]==null){
				possibleMoves.add(new Queen(qrow,qcol+i,side));
			}else{
				break;
			}
		}
		//North-West Check (Diagonal Operation)
		for(int i=1;qrow-i>=0 && qcol-i>=0;i++){
			if(board[qrow-i][qcol-i]==null){
				possibleMoves.add(new Queen(qrow-i,qcol-i,side));
			}else{
				break;
			}
		}
		//North-East Check (Diagonal Operation)
		for(int i=1;qrow+i<10 && qcol-i>=0;i++){
			if(board[qrow+i][qcol-i]==null){
				possibleMoves.add(new Queen(qrow+i,qcol-i,side));
			}else{
				break;
			}
		}
		//South-East Check (Diagonal Operation)
		for(int i=1;qrow+i<10 && qcol+i<10;i++){
			if(board[qrow+i][qcol+i]==null){
				possibleMoves.add(new Queen(qrow+i,qcol+i,side));
			}else{
				break;
			}
		}
		
		//South-West Check (Diagonal Operation)
		for(int i=1;qrow-i>=0 && qcol+i<10;i++){
			if(board[qrow-i][qcol+i]==null){
				possibleMoves.add(new Queen(qrow-i,qcol+i,side));
			}else{
				break;
			}
		}
		
		return possibleMoves;
	}
	
	
	
	
	
}
